from typing import *
'''
    Leetcode原题， next permuation， <1, 2, 3>按照字典顺序进行排序的所有permutaiton有：
    <1, 2, 3>, <1, 3, 2>, <2, 1, 3>, <2, 3, 1>, <3, 1, 2>, <3, 2, 1>
    given a permutaton, find the next permutation
    直接拿[1, 2, 3, 4， 5]作为一个concrete example是最好的寻找规律的方法
'''

def EPI_sol(A: List[int]) -> List[int]:
    #   1.  我们要找到折返点，invertion point i， （也可以把i称之为锚点）
    #       锚点意义在于：锚点的右侧已经完成了最后一次的字典排序，已经是降序（或者只有一个element）
    #       为什么要从右往左呢， 因为我们的字典顺序是从左往右的， 
    #       所以要找到右侧起最长递减序列，并且在其基础上进行下一次排序
    #       如果从左侧起就不是离当前最近的的next permutation

    i = len(A) - 2 #我们的锚点
    while(i >= 0 and A[i] > A[i + 1]):
        i -=1
    
    if i == -1: return [] #如果全部喂降序， 则当前为最后的字典排序

    #   2.  我们知道锚点的位置， 并且知道锚点右侧已经完成了字典排序，成降序排列
    #       所以下一个permutation是什么呢？注意我们的字典顺序是从小到大
    #      【所以是右侧降序排列里：比锚点大里最小的那个数字】
    #       我们怎么找到比锚点大且最小的呢？已知我们的锚点的右侧是降序， 最小的从右边起
    #       我们只需要从右侧起手，找到第一个比锚点大的, 也一定是比锚点大的里面最小的
    print(A[i])
    for j in reversed(range(i, len(A))):
        if A[j] > A[i]:
            A[j], A[i] = A[i], A[j]
            break
    #   3.  新的锚点的最小顺序一定是升序排列，我们只需要把交换过后的部分进行排序即可
    #       但更细心的观察你会发现， 我们只需要颠倒顺序即可， 因为经过swap过后已经是decreasing order
    #       [6, 2, 3, 5, 4, 1, 0]，已知我们的新的锚点（4）比旧锚点（3）大， 
    #       并且新锚点的右侧一定小于等于旧锚点小（如果不小于等于，那么我们遍历的时候一定会找到这个新锚点）
    #       新锚点（4）的左边既然大于等于 新锚点， 且新锚点大于旧锚点， 那么新锚点的左侧也一定大于旧锚点
    #       结论：调换之后， 我们的依然可以保持降序排列， 若要进行升序排列， 不需要调用排序算法， 直接颠倒即可
    A[i + 1:] =  reversed(A[i + 1:])
    return A

A = [6, 2, 3, 5, 4, 1, 0]

res = EPI_sol(A)

print(res)

